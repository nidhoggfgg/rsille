//! Event routing system
//!
//! Routes events to appropriate handlers (global, focus navigation, widget handlers)

use crate::{
    event::{Event, KeyCode, KeyModifiers},
    focus::FocusManager,
    layout::Layout,
};
use rustc_hash::FxHashMap;

/// Event router for handling event distribution
///
/// Routes events to:
/// - Global key handlers
/// - Focus navigation (Tab/Shift+Tab)
/// - Widget event handlers
pub struct EventRouter<M> {
    /// Global key handlers registered by the application
    global_key_handlers: FxHashMap<KeyCode, Box<dyn Fn() -> M + Send + Sync>>,
}

impl<M> EventRouter<M>
where
    M: Clone + std::fmt::Debug,
{
    /// Create a new event router
    pub fn new() -> Self {
        Self {
            global_key_handlers: FxHashMap::default(),
        }
    }

    /// Add a global key handler
    pub fn add_global_handler<F>(&mut self, key: KeyCode, handler: F)
    where
        F: Fn() -> M + Send + Sync + 'static,
    {
        self.global_key_handlers.insert(key, Box::new(handler));
    }

    /// Route a single event
    ///
    /// Returns (should_continue, messages, needs_redraw, focus_changed)
    pub fn route_event(
        &self,
        event: &Event,
        layout: &mut Box<dyn Layout<M>>,
        focus_manager: &mut FocusManager,
    ) -> RouteResult<M> {
        // Intercept Tab/Shift+Tab for focus navigation
        if let Event::Key(key_event) = event {
            match key_event.code {
                KeyCode::Tab if key_event.modifiers.contains(KeyModifiers::SHIFT) => {
                    // Focus previous widget
                    focus_manager.focus_prev();
                    return RouteResult {
                        messages: Vec::new(),
                        needs_redraw: true,
                        focus_changed: true,
                    };
                }
                KeyCode::Tab => {
                    // Focus next widget
                    focus_manager.focus_next();
                    return RouteResult {
                        messages: Vec::new(),
                        needs_redraw: true,
                        focus_changed: true,
                    };
                }
                _ => {}
            }

            // Check global key handlers before routing to widgets
            if let Some(handler) = self.global_key_handlers.get(&key_event.code) {
                let message = handler();
                return RouteResult {
                    messages: vec![message],
                    needs_redraw: true,
                    focus_changed: false,
                };
            }
        }

        // Route event to widgets with focus information
        let focus_id = focus_manager.focus_id();
        let registry = &focus_manager.registry;
        let (_result, messages) = layout.handle_event_with_focus(event, focus_id, registry);

        let needs_redraw = !messages.is_empty();

        RouteResult {
            messages,
            needs_redraw,
            focus_changed: false,
        }
    }
}

impl<M> Default for EventRouter<M>
where
    M: Clone + std::fmt::Debug,
{
    fn default() -> Self {
        Self::new()
    }
}

/// Result of routing an event
#[derive(Debug)]
pub struct RouteResult<M> {
    /// Messages generated by event handling
    pub messages: Vec<M>,
    /// Whether a redraw is needed
    pub needs_redraw: bool,
    /// Whether focus changed
    pub focus_changed: bool,
}
